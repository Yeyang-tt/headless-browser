package com.yeyang.browser.headless.util;


import cn.hutool.core.io.FileUtil;
import lombok.extern.slf4j.Slf4j;
import org.apache.batik.dom.GenericDOMImplementation;
import org.apache.batik.svggen.SVGGeneratorContext;
import org.apache.batik.svggen.SVGGraphics2D;
import org.apache.pdfbox.pdmodel.PDDocument;
import org.apache.pdfbox.pdmodel.PDPage;
import org.apache.pdfbox.pdmodel.PDPageTree;
import org.apache.pdfbox.rendering.PDFRenderer;
import org.w3c.dom.DOMImplementation;
import org.w3c.dom.Document;

import java.awt.*;
import java.awt.color.ColorSpace;
import java.awt.geom.AffineTransform;
import java.awt.image.ColorModel;
import java.awt.image.ComponentColorModel;
import java.awt.image.DataBuffer;
import java.io.*;
import java.util.ArrayList;
import java.util.List;

/**
 * SVG Utils
 *
 * @author Yeyang
 * @date 2024/10/08
 */
@Slf4j
public class SvgUtils {

    public static GraphicsConfiguration deviceConfiguration;

    /**
     * pdf转svg
     *
     * @param fileName 文件名
     * @return {@link List }<{@link String }>
     * @throws IOException IOException
     */
    public static List<String> pdfToSvg(String fileName) {
        try {
            String filePath = PdfConvertUtil.workPath(fileName);
            InputStream is = new FileInputStream(filePath);
            PDDocument document = PDDocument.load(is);
            PDFRenderer pdfRenderer = new PDFRenderer(document);
            SVGGeneratorContext ctx = createContext();
            PDPageTree pages = document.getPages();

            int pageCounter = 0;
            String prefix = FileUtil.getPrefix(fileName);
            List<String> svgList = new ArrayList<>();
            for (PDPage page : pages) {
                long start = System.currentTimeMillis();
                SVGGraphics2D g = createGraphics(ctx);
                deviceConfiguration = g.getDeviceConfiguration();
                pdfRenderer.renderPageToGraphics(pageCounter, g);

                String svgFileName = String.format("%s_%s.svg", prefix, pageCounter + 1);
                Writer out = new OutputStreamWriter(new FileOutputStream(PdfConvertUtil.workPath(svgFileName)));
                g.stream(out, true);
                svgList.add(svgFileName);
                long end = System.currentTimeMillis();
                log.debug("Svg工具-转换Svg-第{}张：{};耗时：{}", pageCounter + 1, svgFileName, end - start);
                pageCounter++;
            }
            return svgList;

        } catch (IOException e) {
            log.error("Svg工具-转换Svg-转换失败", e);
        }
        return null;
    }

    public static SVGGraphics2D createGraphics(SVGGeneratorContext ctx) {
        SVGGraphics2D g2d = new CustomSVGGraphics2D(ctx, false);
        return g2d;
    }

    public static SVGGeneratorContext createContext() {
        DOMImplementation impl = GenericDOMImplementation.getDOMImplementation();
        String svgNS = "http://www.w3.org/2000/svg";
        Document myFactory = impl.createDocument(svgNS, "svg", null);

        SVGGeneratorContext ctx = SVGGeneratorContext.createDefault(myFactory);
        ctx.setComment("Generated by FooApplication with Batik SVG Generator");
        return ctx;
    }

    public static class CustomSVGGraphics2D extends SVGGraphics2D {

        public CustomSVGGraphics2D(SVGGeneratorContext generatorCtx, boolean textAsShapes) {
            super(generatorCtx, textAsShapes);
        }

        @Override
        public GraphicsConfiguration getDeviceConfiguration() {
            return new CustomGraphicsConfiguration();
        }
    }

    private static final class CustomGraphicsConfiguration extends GraphicsConfiguration {
        @Override
        public AffineTransform getNormalizingTransform() {
            return null;
        }

        @Override
        public GraphicsDevice getDevice() {
            return new CustomGraphicsDevice();
        }

        @Override
        public AffineTransform getDefaultTransform() {
            return null;
        }

        @Override
        public ColorModel getColorModel(int transparency) {
            ColorSpace colorSpace = ColorSpace.getInstance(ColorSpace.CS_sRGB);
            boolean hasAlpha = true;
            boolean isAlphaPremultiplied = true;
            int transferType = DataBuffer.TYPE_BYTE;
            ComponentColorModel colorModel = new ComponentColorModel(colorSpace, hasAlpha, isAlphaPremultiplied, transparency, transferType);

            return colorModel;
        }

        @Override
        public ColorModel getColorModel() {
            ColorSpace colorSpace = ColorSpace.getInstance(ColorSpace.CS_sRGB);
            boolean hasAlpha = true;
            boolean isAlphaPremultiplied = true;
            int transparency = Transparency.TRANSLUCENT;
            int transferType = DataBuffer.TYPE_BYTE;
            ComponentColorModel colorModel = new ComponentColorModel(colorSpace, hasAlpha, isAlphaPremultiplied, transparency, transferType);

            return colorModel;
        }

        @Override
        public Rectangle getBounds() {
            Rectangle rect = new Rectangle(50, 50, 100, 100);

            // Rectangle rect = new Rectangle(100, 200, 500, 300);
            rect.setSize(150, 150);

            return rect;
        }
    }

    private static final class CustomGraphicsDevice extends GraphicsDevice {
        @Override
        public int getType() {
            return 0;
        }

        @Override
        public String getIDstring() {
            return null;
        }

        @Override
        public GraphicsConfiguration[] getConfigurations() {
            return null;
        }

        @Override
        public GraphicsConfiguration getDefaultConfiguration() {

            return deviceConfiguration;
        }
    }
}
